# REST API vs GraphQL vs gRPC
* **API**: acronym for Application Programming Interface. A set of clearly defined methods of communication with other systems.
* API Types
  1. OS APIs : Any apps runs within an OS, apps may needs some functionality from OS like File System, Nw Devices, UI Elements, etc this is achieved via OS APIs.
  2. Library API : In our App, we may use libraries these libraries exposed APIs / methods like User lib may use Logging API from Logging Library. 
  3. Remote API : `This is loosing popularity.`. Eg. .NET Remoting, DCOM, Java RMI 
  4. Web API : It is platform, OS or Language independent.

## Web APIs
* Platform Agnostic, 
* Uses Standard protocols over HTTP, 
* Usually uses Request/Response based model
* **Web API differentiating factors**:
  *  Request Format - JSON, XML, Binary
  *  Request Content 
  *  Response Format 
  *  Response Contents
* **Types**
  1. SOAP
  2. REST
  3. GraphQL
  4. gRPC

1. **{`OutDated`}SOAP**: acronym for Simple Object Access Protocol in 1998 and is XML Based and it uses RPC Style i.e. client calls a very specific method. 

## REST APIs (Representational State Transfer)
* It enables transfer of representation of a resources's state.
* **State**: It is current resource properties or result of an action on the resource(like resource created, deleted, updated).
* `Client` --Request for resource state --> `Server`
* `Server` --Returns representation of resource in some format like json --> `Client`
<br/>

* A Request has 
  1. Method: Http Verb (Get, Put, Post, Patch, Delete)
  2. URL: Location of the resource + parameters
  3. Headers: Meta-data of the request (User Agent...)
  4. Body: (Optional) Contents of the request.
* A Response has
  1. Status Code: 3 Digit no representing success or problem
  2. Headers: Meta data
  3. Body: (Optional) Content of response  
* Http Verbs: It Set the action to be performed. Using correct verb improves readability
  * **GET**: 
    1. Used to retrieve resource(s)
    2. NEVER use it to add/update/delete
    3. The default verb of browser is GET
    4. Should not use any body.
   * **POST**
     * Add Resource
     * Should contain a message body that specifies the resource to be added
     * Should not contain query params
   * **PUT**
     * Used to modify resource(s)
     * Should contain a message body that specifies the resource to be modified.
     * Should not contain query string parameters.
   * **DELETE**
     * Used to delete resource(s)
     * Always combined with Params.
   * **PATCH**
     * It is used to make partial modifications to an existing resource. Unlike PUT which replaces the complete resource with a new representation. 
     * Eg. Using to update single property of the resource like status of a task from pending to completed. 
<br/>

* **URL**: Defines the structure of API URL. 
  * Structure should be self explanatory
  * It should be consistent across API
  * It should be predictable.
  * **Use Nouns, No Verb** 
    * Describe resources with nouns like `/users` or `/products`.
    * Avoid verbs like `/create_user` or `/update_product`.
  * **Name Collections with plural nouns**
  * Organize URLs into hierarchy. `api/users/123/orders`
  * **Include API version**
  * Use ID param to indicate a specific entity to work with.
  * **No Long Phrases use short focused words**
  * Minimize use of query params , this should be limited to only filtering or sorting options.
  * **Use Lowercase and hyphens for separators**
  * `api_word/versioning/entity_name/id_if_working_with_specific_entity/sub-entity?query_param=value`
  * Eg. `/api/v1/entity/id_param/sub-entity?query_param=value&query_param2=value2` 
<br/>

* **RESPONSE**
  * Status Codes: Notify clients about status of request.
    * 1XX Group: Informational Response. Used for internal usage and we should not use it.
    * 2XX Group: Success 
      * 200 OK: If everything went as expected
      * 201 Created
      * 202 Accepted: Request was accepted but server will take care of this latest or like it is still processing.
      * 203 Non Authoritative Information: Server is returning information that was not generated by the origin server.
      * 204 No Content: The request is successful but no content to return.
    * 3XX Group: Redirection
    * 4XX Group: Client Errors
      * 400
      * 401
      * 403 Forbidden : Authenticated but not Authorized
      * 404 Not Found: Resource that does not exist.
    * 5XX Group: Server Errors
      * 500 Something bad happened while processing the request.
<br/>

* **Versioning**
  * Assumptions while designing is APIs will be updated in future.
  * We can't force clients to follow our version updated in APIs hence versioning helps our client to continue using our APIs. 
  * **Set a version support policy** like API End-of-Life statement.
  * Include versioning in APIs
    * [Common] & [Easiest] In the URL: `api/v20.0` - In some way it is contamination of URL as as per REST Url must represent an entity & this ver is extra information.
    * In the header: `Accept: application/vnd.myname.v1+json` - MOST Correct form.
    * [Do not Use] In a query param: `users/1234?version=4.0`

* **HATEOAS** - Hypermedia As the engine of application state.it states that API should provide hypermedia(links) to guide client through the application state. 
  * Server should tell client what it can do next rather then client knowing what all it can do.
  * When calling a REST API and getting an entity response then entity should contain pointers to the related entities you may be interested in.
  * Client should not have prior knowledge about other resources.
  * It is useful in
    * Client discovery - HATEOAS allows to discover new resources and actions dynamically.
    * Flexibility - APIs can evolve by adding new links without needing existing clients to update.
    * Decouples client to specific interaction patterns.
  * Eg. **Genie** by netflix which is a giant job scheduler. 
    * It returns
    ```json
    {
        ...response,
        "_links": {
            "self": {
                "href": ""
            },
            "output": {
                "href": ""
            },
            ...
        }
    }
    ```

## GraphQL
* **Problems with REST**:
  * Fixed entity structure: Client cannot specify entity parts it wants to retrieve and cannot be modified by per request basis. This increases load time and network latency which forces to create specialized entity types just for specific queries. This is bad for maintenance and data model.
  * Request Response Pattern Only: Modern web apps requires push notifications or other modern communication hence REST fails here. 

* Fb developed it as replacement of REST APIs for internal use and this was open sourced in 2015. 
* It is managed my GraphQL Foundation.
* GraphQL is :
  * Specification: Defines the semantics and components of a GQL API, Does not provide concrete implementation. Other parties develop implementation in many languages. [SPEC Link](https://github.com/graphql/graphql-spec)
  * Defines structure of data returned: We can specify part of entity to return and can specify related entities to be returned and can specify filtering in the query.
  * JSON based: Query is sent in JSON and data is also returned in JSON. This can be used with other platforms.
  * 3 Types of Operation: Retrieve, Write or change and Subscribe to changes in data.
  * Schema based: Works with schema defining entities, fields and attributes. operations are built on schema.
  * Cross Platform: Client and server can be based on any platform.
<br/>

* **HOW TO IMPLEMENT?**
  * Define Schema
  * Define Query
  * Optional Defining mutations and subscriptions
  * Implementing the logic.
<br/>

* **Role of schema**:
  * GQL needs to know which object exist and what fields it contains - Shape of object. 
  * This is used to define & validate queries, validate operations, Provide auto complete in playground
  * **Schema Type System** - Schema Definition Language SDL
    * Field Name
    * Field Type
    * Nullability 
  * Schema can be auto generated based on concrete language object description
<br/>

* **GQL Server Roles**
  * Enforce GQL Specifications
  * Define GQL Schema:
    * It is done using code elements in server or explicitly using SDL
    * It is based on classes/modules
  * Expose GQL Endpoint
    * All GQL operations are sent to a specific single endpoint as opposed to REST API
  * Validate GQL Operations
    * The server receives the JSON payload and validates it against the schema. If mismatch is found then the server returns a standard error message. No coding is required for this validation.
  * Route GQL Operations to code
    * the server converts the JSON payload to objects and triggers the methods to process the operations and return the data.
    * These methods are called **resolvers**
    * The server traverses through the query and runs a resolver for every field. 
    * If the field returns a scalar value this is what is returned
    * If the field returns an object value - the server runs resolvers for each field in the object and this is repeated unless a scaler value is returned.
    * Resolvers in the same hierarchy run in parallel
    ```graphql
    {
        books { <-- Resolver on book object - Returns book object
            name
            pages <-- all 3 the resolvers are run in parallel but 2 return scaler value
            author { <-- Resolver fo the author element returns object value
                name <-- Resolver of the name element which return scalar value
            }
        }
    }
    ```
    * Most implementations automatically create resolver for all fields -> like hot chocolate, 
    * Custom resolvers can also be specified.
    * resolvers can accept arguments with context data about the query.
  * Return GQL Results
    * Server converts object to json and returns it to the client.
<br/>

* **DEMO**
  * Playground: https://studio.apollographql.com/public/star-wars-swapi/variant/current/explorer
  * Operation 1
```graphql
  {
  allFilms {
    films {
      title, 
      director
    }
  }
}
```

## gRPC
* Problems of REST
  * Performance : REST used text based protocols HTTP 1.1 like JSON but text based exchange makes large packets and parsing is another cause of performance hit.
  * Request Response Only: Modern apps require more types of communication apart from Request-Response model.
  * Limited Syntax: REST was designed to run CRUD on entities, This is not suited for running actions like disable a device etc.
<br/>

* **History**
  * google developed & called it stubby and in 2015 google open sourced it 
  * It promotes messages and services and not objects and reference.
  * Available on every platform and free and open source.
  * Performant
  * Allow streaming
<br/>

* **gRPC Basics**
  * Web API
    * Running through internet & connecting services built on different platforms. 
  * Based on HTTP/2
    * HTTP 1.1 was released in 1997
    * HTTP 2 released in 2015
    * Fully compatible with HTTP 1.1
    * Main diff is connection between client and server. Allows streaming from both sides in addition to req-res model.
    * It can not be used from browsers. Used mainly from native mobile apps in the backend but there is workaround for frontend/
  * RPC Style
    * g - Google, RPC - Remote Procedure Calls
    * Calling a method on the server from the client. `Client` ---GetWeather("NYC")-->`Server(GetWeather("NYC"))`. In REST we can't call methods we call through URL. 
  * Multiple communication Styles
    * Unary
      * Request Response Model like REST. Request is calling actual methods.
    * Client Streaming
      * Client opens connections and sends continuous messages to the server.
      * Great for telemetry, chats, etc 
    * Server Streaming
      * Client opens a connection and server sends continuous messages to the client
    * Bi Directional
      * Client opens connection and both client and server sends the data in real time.
  * Uses Protobuf as Payload
    * data format used by gRPC like JSON used by REST. gRPC can also use other data formats
    * Binary format
    * Declares messages format in a .proto file
    * Generates files based on this .proto files.
<br/>

* **Error Handling**
  * gRPC doesn't use HTTP Status code, it returns status code and additional status code
  * like canceled, deadline_exceeded, unavailable, internal
  * [gRPC Error Status Code List](https://grpc.io/docs/guides/error/#error-status-codes)

* **Channels**
  * A defination of connection between client and server
  * Specifies host and port.
  * has a state - connected or idle

* **Deadline** and **timeout**

## Comparing Web APIs
* Decision to use any type is based on client type, actions, protocols

| Param | REST | GraphQL | gRPC |
|  :---: | :---: |  :---: |  :---: |
| Simplicity | Yes | No  | No |
| Flexibility to work with entities like getting parts of it| No | Yes | No |
| Performance | YES NO | No | YES |
| Push Notification | No | Yes | Yes | 
| Native Browser Support | Yes | Yes | No |
| Semantics | Entities | Entities | Actions |

* **Flow Chart of Selecting APIs**
* [Here](https://memilavi.com/web-apis-flowchart/)